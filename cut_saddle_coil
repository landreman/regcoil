#!/usr/bin/env python
print "usage: cut_saddle_coil regcoil_out.name nescin.name ilamda"

###################################################################

def real_space(plas,theta,zeta):
	npoints = len(theta)
	r = np.zeros(npoints)
	z = np.zeros(npoints)
	x = np.zeros(npoints)
	y = np.zeros(npoints)
	for ipoint in range(npoints):
		tmpr = plas['Rbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta[ipoint]) + \
			plas['Rbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta[ipoint])
		r[ipoint] = np.sum(tmpr) #r value at ipoint
		x[ipoint] = r[ipoint]*np.cos(zeta[ipoint])
		y[ipoint] = r[ipoint]*np.sin(zeta[ipoint])
		tmpz = plas['Zbc']*np.cos(plas['m']*theta[ipoint]+plas['n']*zeta[ipoint]) + \
			plas['Zbs']*np.sin(plas['m']*theta[ipoint]+plas['n']*zeta[ipoint])
		z[ipoint] = np.sum(tmpz) #z value at ipoint
	return x, y, z

def read_winding_surface(filename):
    with open(filename, 'r') as f:
        line = ''
        while "np     iota_edge       phip_edge       curpol" not in line:
            line = f.readline()
        line = f.readline()
        nfp = int(line.split()[0])
        print "nfp:",nfp

        line = ''
        while "------ Current Surface:" not in line:
            line = f.readline()
        line = f.readline()
        line = f.readline()
        #print "Number of Fourier modes in coil surface from nescin file: ",line
        num = int(line)
        plas = np.zeros(num, dtype=[('m',np.float64), ('n', np.float64), #m,n saving as double
                                         ('Rbc', np.float64), ('Zbs', np.float64),
                                         ('Rbs', np.float64), ('Zbc', np.float64) ])
        line = f.readline() #skip one line
        line = f.readline() #skip one line
        for i in range(num):
            line = f.readline()
            plas[i] = tuple([float(j) for j in line.split()])
        plas['n'] *= nfp
	return plas

def com_two_angles(a, b, tol=0.0314):
	# print "{:12.5E} {:12.5E} ; {:12.5E} {:12.5E} ; {:12.5E} {:12.5E} ;".format(a[0], a[1], b[0], b[1], abs(a[0] - b[0]), abs(a[1] - b[1]))
	if abs(a[0] - b[0]) < tol or 2*np.pi-abs(a[0] - b[0]) < tol:
		if abs(a[1] - b[1]) < tol or 2*np.pi-abs(a[1] - b[1]) < tol:
			return True
	return False

def combine_lines(lines):
	p_sta = [iline[ 0,:] for iline in lines] # starting points
	p_end = [iline[-1,:] for iline in lines] # ending points

   # not for helical coils or coils with more sections
	new_lines = []
	used_index = []
	for i in range(len(lines)):
		init_len = len(used_index)
		# if i not in used_index:
		for j in range(len(lines)):
			if j == i :
				continue
			if com_two_angles(p_sta[i], p_sta[j]):
				print "find continued starting points of ", i, " and ", j
				new_lines = list(np.delete(lines, [i,j], 0))
				lines[j] = np.delete(lines[j], 0, axis=0)
				new_lines.append(np.concatenate((lines[i][::-1], lines[j])))
				return combine_lines(new_lines)
				#used_index.append(j)
				#continue
			if  com_two_angles(p_sta[i], p_end[j]):
				print "find continued starting points of ", i, " and ending points of ", j
				new_lines = list(np.delete(lines, [i,j], 0))
				lines[i] = np.delete(lines[i], 0, axis=0)
				new_lines.append(np.concatenate((lines[j], lines[i])))
				return combine_lines(new_lines)
				#used_index.append(j)
				#continue
		if len(used_index) == init_len:	
			new_lines.append(lines[i])
	#raw_input('Enter something to continue...')
	#print len(new_lines)
	if used_index == [] :
		return lines
	else:
		return combine_lines(new_lines)

###################################################################

from scipy.io import netcdf
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import sys

if len(sys.argv) < 4:
   print "Error! Wrong number of arguments."
   exit(1)

regcoilname = sys.argv[1]
surfname = sys.argv[2]
ilambda = int(sys.argv[3])
symmetry = bool(sys.argv[4])
#num_of_contours = int(sys.argv[4])

print(sys.version)
print 'regcoilname: ', regcoilname
print 'surfname: ', surfname
print "ilambda:",ilambda

f = netcdf.netcdf_file(regcoilname,'r',mmap=False)
nfp = f.variables['nfp'][()]
ntheta_plasma = f.variables['ntheta_plasma'][()]
ntheta_coil = f.variables['ntheta_coil'][()]
nzeta_plasma = f.variables['nzeta_plasma'][()]
nzeta_coil = f.variables['nzeta_coil'][()]
nzetal_plasma = f.variables['nzetal_plasma'][()]
nzetal_coil = f.variables['nzetal_coil'][()]
theta_plasma = f.variables['theta_plasma'][()]
theta_coil = f.variables['theta_coil'][()]
zeta_plasma = f.variables['zeta_plasma'][()]
zeta_coil = f.variables['zeta_coil'][()]
zetal_plasma = f.variables['zetal_plasma'][()]
zetal_coil = f.variables['zetal_coil'][()]
r_plasma  = f.variables['r_plasma'][()]
r_coil  = f.variables['r_coil'][()]
xm_coil = f.variables['xm_coil'][()]
xn_coil = f.variables['xn_coil'][()]
xm_potential = f.variables['xm_potential'][()]
xn_potential = f.variables['xn_potential'][()]
mnmax_coil = f.variables['mnmax_coil'][()]
chi2_B = f.variables['chi2_B'][()]
single_valued_current_potential_thetazeta = f.variables['single_valued_current_potential_thetazeta'][()]
current_potential = f.variables['current_potential'][()]
Bnormal_from_plasma_current = f.variables['Bnormal_from_plasma_current'][()]
Bnormal_from_net_coil_currents = f.variables['Bnormal_from_net_coil_currents'][()]
Bnormal_total = f.variables['Bnormal_total'][()]
net_poloidal_current_Amperes = f.variables['net_poloidal_current_Amperes'][()]
phi_mn = f.variables['single_valued_current_potential_mn'][()][ilambda,:]
K2 =  f.variables['K2'][()][ilambda,:,:]
f.close()

mn_max = len(xm_potential)
phi_sin = phi_mn[0:mn_max]
phi_cos = phi_mn[mn_max:]

####### define fucntion #######
def func(x):
    '''
    x = [theta,zeta]
    '''
    angle = xm_potential*x[0] - xn_potential*x[1]
    phi = np.sum(phi_cos * np.cos(angle) + phi_sin * np.sin(angle))
    return phi

def func2(x):
    '''
    square of phi
    '''
    return func(x)*func(x)

##### test ######

#phi_thetazeta = np.zeros([ntheta_coil, nzeta_coil])
#for itheta in range(ntheta_coil):
#    for jzeta in range(nzeta_coil):
#        phi_thetazeta[itheta, jzeta] = func([theta_coil[itheta], zeta_coil[jzeta]])

#plt.figure()
#plt.imshow(phi_thetazeta)

####### define gradient #######
def jac(x):
    '''
    jac = [df/dx, df/dy]
    '''
    angle = xm_coil*x[0] - xn_coil*x[1]
    dphi_dtheta = np.sum(phi_cos * (-1.0) * xm_coil * np.sin(angle) + phi_sin * ( 1.0) * xm_coil * np.cos(angle))
    dphi_dzeta  = np.sum(phi_cos * ( 1.0) * xn_coil * np.sin(angle) + phi_sin * (-1.0) * xn_coil * np.cos(angle))
    return np.array([dphi_dtheta, dphi_dzeta])

def jac2(x):
    '''
    gradient of square phi
    '''
    return 2.0*func(x)*jac(x)

##### test ########
#eps = np.sqrt(np.finfo(float).eps)
#x = [0,np.pi]
#optimize.approx_fprime(x, func, eps)
#jac(x)

###### hessian ########
def hess(x):
    '''
    hessian of phi
    '''
    angle = xm_coil*x[0] - xn_coil*x[1]
    dphi_dtheta_dtheta = np.sum(phi_cos * (-1.0) * xm_coil * xm_coil * np.cos(angle) +
                                phi_sin * (-1.0) * xm_coil * xm_coil * np.sin(angle))
    dphi_dtheta_dzeta  = np.sum(phi_cos * ( 1.0) * xm_coil * xn_coil * np.cos(angle) +
                                phi_sin * ( 1.0) * xm_coil * xn_coil * np.sin(angle))
    dphi_dzeta_dtheta  = dphi_dtheta_dzeta
    dphi_dzeta_dzeta   = np.sum(phi_cos * (-1.0) * xn_coil * xn_coil * np.cos(angle) +
                                phi_sin * (-1.0) * xn_coil * xn_coil * np.sin(angle))
    return np.array([[dphi_dtheta_dtheta, dphi_dtheta_dzeta],[dphi_dzeta_dtheta, dphi_dzeta_dzeta]])

##### test ########

fig = plt.figure()
ax = fig.add_subplot(111)
#ax.contour(zeta_coil, theta_coil, current_potential_plot, 500, cmap='jet')
ax.contour(zeta_coil, theta_coil, K2, 10, linewidths=2.0, linestyles='dashed', color='w', alpha=0.99)
ax.set_xlabel('zeta')
ax.set_ylabel('theta')

current_potential_plot = current_potential[ilambda,:,:]
new_zeta = zeta_coil.copy()
new_theta = theta_coil.copy()
new_potential = current_potential_plot.copy()
d = 2*np.pi/nfp
for ifp in range(nfp-1):
	new_zeta = np.concatenate((new_zeta,zeta_coil+d*(ifp+1)))
	#new_theta = np.concatenate((new_theta,theta_coil))
	new_potential = np.concatenate((new_potential, current_potential_plot))
zeta_coil = np.append(new_zeta, 2.0*np.pi)
theta_coil = np.append(new_theta, 2.0*np.pi)
current_potential_plot = np.zeros([len(theta_coil), len(zeta_coil)])
current_potential_plot[0:len(theta_coil)-1, 0:len(zeta_coil)-1] = np.transpose(new_potential)
current_potential_plot[  len(theta_coil)-1, 0:len(zeta_coil)-1] = np.transpose(new_potential)[0,:]
current_potential_plot[0:len(theta_coil)-1,   len(zeta_coil)-1] = np.transpose(new_potential)[:,0]
current_potential_plot[  len(theta_coil)-1,   len(zeta_coil)-1] = np.transpose(new_potential)[0,0]
print np.shape(zeta_coil), np.shape(theta_coil), np.shape(current_potential_plot)

# loop
surface_array = read_winding_surface(surfname)
#print "mtotal:", mtotal

coilsFilename = 'coils.'+regcoilname[12:-3]
f = open(coilsFilename,'w')
f.write('periods '+str(nfp)+'\n')
f.write('begin filament\n')
f.write('mirror NIL\n')

num_contour = 0
level = []
max_number = np.max(current_potential_plot) + 1E6

# plot current_potential
#fig = plt.figure()
#ax = fig.add_subplot(111)
ax.contour(zeta_coil, theta_coil, current_potential_plot, 500, cmap='jet', alpha=0.25)
#ax.contour(zeta_coil, theta_coil, K2, 500, cmap='coolwarm', alpha=0.75)
#ax.set_xlabel('zeta')
#ax.set_ylabel('theta')
#plt.show()


def onclick(event):
	print "------------------------------------------"
	print "Please click the screen to choose contours."
	print "To finish, please close the figure."
	xdata = event.xdata
	ydata = event.ydata
	print xdata, ydata
	tmp_value = func([ydata,xdata])
	print "clicked contour value :", tmp_value
	level.append(tmp_value)
        if symmetry :
                level.append(-tmp_value)
                tmp_array = np.sort([tmp_value, -tmp_value])
        else :
                tmp_array = [tmp_value]
        for tmp_value in tmp_array:
                tmp_level = np.atleast_1d(tmp_value)

                cdata = ax.contour(zeta_coil,theta_coil,current_potential_plot, tmp_level)

                lines = [p.vertices for p in cdata.collections[0].get_paths()[:]] # get all the lines
                print "number of raw contour lines: ", len(lines)
                new_lines = combine_lines(lines)
                print "number of closed contour lines: ", len(new_lines)
                for icoil in new_lines:
                        contour_zeta = icoil[:,0]
                        contour_theta = icoil[:,1]
                        X,Y,Z = real_space(surface_array,contour_theta,contour_zeta)

                        for ii in range(len(X)-1):
                                f.write('{:23.15E} {:23.15E} {:23.15E} {:23.15E}\n'.format(X[ii],Y[ii],Z[ii], tmp_value))
                        ii=0
                        f.write('{:23.15E} {:23.15E} {:23.15E} {:23.15E} {:d} RMP \n'.format(X[ii],Y[ii],Z[ii], 0.0, 1))

fig.canvas.mpl_connect('button_press_event', onclick)
plt.show()

f.write('END \n')
f.close()

plt.figure()
plt.contour(zeta_coil,theta_coil,current_potential_plot,np.sort(level))
plt.savefig(regcoilname[12:-3]+'_cp.png')
plt.show()
